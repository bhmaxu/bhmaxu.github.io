<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>java多线程（3） | 马旭的博客</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java多线程（3）</h1><a id="logo" href="/.">马旭的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about-me/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">java多线程（3）</h1><div class="post-meta"><a href="/2020/03/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%883%EF%BC%89/#comments" class="comment-count"></a><p><span class="date">Mar 22, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h2 id="Balking模式"><a href="#Balking模式" class="headerlink" title="Balking模式"></a>Balking模式</h2><p>Balk在这里的意思大概是“<strong>停止并返回</strong>”，棒球中的投手犯规就是这个词。在充分理解前面的Guarded Suspension模式后，学习Balking模式应该是相当容易的。我们可以看一下在某些场景下Guarded Suspension模式可能存在的缺点。Guarded Suspension模式中如果守护条件得不到满足，那么该线程将一直处于阻塞状态，在很多情况下，如上一篇文章中提到的多线程队列，而在另外的情况下，我们其实<strong>可以直接返回，而不必使线程阻塞</strong>，从而提高性能，这就是Balking模式。</p>
<p>比如在文本的自动保存中，我们可能会用到一个单独的定时启动的线程判断文本是否修改，如果没有修改（不满足守护条件），那么线程可以直接返回，而不必阻塞。由于思路只是在Guarded Suspension的基础上稍作改变，这里就不给出代码示例了。</p>
<h2 id="Producer-Consumer模式"><a href="#Producer-Consumer模式" class="headerlink" title="Producer-Consumer模式"></a>Producer-Consumer模式</h2><p>接下来是经典的生产者-消费者模型。生产者负责生产“商品”，消费者负责购买“商品”。当生产者和消费者都由同一个线程控制时，这似乎没有什么难的。但如果还原现实，生产者和消费者分别由单独的线程控制，甚至有多个生产者和消费者（多个线程），那么就需要一个桥梁来连接生产者和消费者。这个中介桥梁大多数情况是有限的，只能放置有限个商品。生产者生产的商品需要放到桥梁上，当桥梁满时，需要等待；而消费者需要通过桥梁购买商品，当桥梁上没有商品时，也需要等待。Producer-Consumer模式就是为了解决这种线程之间处理速度有差异的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bridge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] buffer; <span class="comment">//放置商品的容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail; <span class="comment">//下次放置商品的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head; <span class="comment">//下次拿走商品的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">//buffer中商品的数目</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Brdige</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> Item[total];</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Item item)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt;= buffer.length) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[tail] = item;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % count;</span><br><span class="line">        count++;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Item <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        Item item = buffer[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % count;</span><br><span class="line">        count--;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述Brdige模拟的是生产者消费者沟通的桥梁，put由生产者调用，将商品放在桥梁里；get由消费者调用，获取放置在桥梁里的商品。如果您已经完全理解了之前的Guarded Suspension模式，那么也许会觉得get和put的逻辑无比简单。首先，get和put都必须被synchronized关键字修饰，即获得锁的线程才可以调用，避免冲突。其次，get和put方法的内部使用了Guarded Suspension模式。如果不满足守护条件，即生产者遇到buffer满的情况，或是消费者遇到buffer为0的情况，线程都会被阻塞，直到另外一方调用相应方法，进而notify。由此保证了当生产者和消费者不同步时，程序也能正常执行。</p>
<h3 id="对InterruptedException异常的理解"><a href="#对InterruptedException异常的理解" class="headerlink" title="对InterruptedException异常的理解"></a>对InterruptedException异常的理解</h3><p>该异常会由以下三个方法抛出：</p>
<ul>
<li>java.lang.Object.wait</li>
<li>java.lang.Thread.join</li>
<li>java.lang.Thread.sleep</li>
</ul>
<p>InterruptedException表示该方法可能会<strong>花费时间</strong>，但<strong>可以取消</strong>。</p>
<ul>
<li>花费时间。wait方法调用后线程会进入等待队列，直到notify’或notifyAll，sleep方法调用后线程会被暂停一定的时间，join方法调用后，线程会等待指定线程终止。</li>
<li>可以取消。对由于执行上述三个方法而暂停的线程t，可以由别的线程执行t.interrupt()来唤醒线程t，控制权会被传递给catch到InterruptedException的语句块。值得注意的是，wait方法的情况下，我们需要注意锁的情况，只有线程t重新获得锁，它才会抛出异常。</li>
</ul>
<h2 id="Thread-Per-Message模式"><a href="#Thread-Per-Message模式" class="headerlink" title="Thread-Per-Message模式"></a>Thread-Per-Message模式</h2><p>该模式直译就是每个消息一个线程，这里的消息主要指一些非常耗时的操作如IO等，意思就是把耗时的操作交给另外一个线程来执行，进而提高程序的相应性。这体现的是多线程程序的一个很重要的作用，就是提高程序的相应性，降低延迟。在Thread-Per-Message模式中，每一个message（耗时的操作）到来时，都会创建一个新的线程去执行，而主线程会立即返回，执行其他的操作。我们用Client来表示类似主线程的角色，由它来发起操作；用Host来表示负责创建线程的类；Helper类表示具体执行耗时操作的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... <span class="comment">//耗时的操作，如IO等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Helper helper = <span class="keyword">new</span> Helper();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                helper.handle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    Host host = <span class="keyword">new</span> Host();</span><br><span class="line">    host.request();</span><br><span class="line">    host.request();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host的实现使用了匿名内部类，把类的声明、创建、方法的调用结合在了一起，具体语法不在这里赘述。</p>
<p>Thread-Per-Message的主要目的是提高程序相应性，降低延迟，但在使用之前，我们需要注意它的一些特点，避免错误使用。</p>
<ul>
<li>操作顺序无法保证。handle的执行并不一定会按照request的调用顺序，异常依赖于顺序的场景该模式是不适用的</li>
<li>没有返回值。handle方法是无法返回值的，因为request方法不会等待handle方法执行完就会返回。如果需要handle的返回值，可以考虑之后会介绍到的Future模式</li>
</ul>
</div><div class="post-copyright"><blockquote><p>Original author: 马旭</p><p>Original link: <a href="https://bhmaxu.github.io/2020/03/22/java多线程（3）/">https://bhmaxu.github.io/2020/03/22/java多线程（3）/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2020/03/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%882%EF%BC%89/" class="next">java多线程（2）</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Balking模式"><span class="toc-text">Balking模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Producer-Consumer模式"><span class="toc-text">Producer-Consumer模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对InterruptedException异常的理解"><span class="toc-text">对InterruptedException异常的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-Per-Message模式"><span class="toc-text">Thread-Per-Message模式</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%883%EF%BC%89/">java多线程（3）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%882%EF%BC%89/">java多线程（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%881%EF%BC%89/">java多线程（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E7%9A%84%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D/">疫情期间的自我反思</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8810%EF%BC%89-%E5%B1%80%E5%9F%9F%E7%BD%91/">计算机网络（10）-局域网</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89/">设计模式（2）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89/">设计模式（1）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%889%EF%BC%89-%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络（9）-链路层</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%888%EF%BC%89-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88part3%EF%BC%89/">计算机网络（8）-网络层（part3）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%887%EF%BC%89-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88part2%EF%BC%89/">计算机网络（7）-网络层（part2）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">16</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">马旭.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>